---
date: 2026-01-13T17:24:51+07:00
researcher: ariasulin
git_commit: 7e5649b56d37976fb00dd567b1f1ee344cace890
branch: main
repository: YouLab
topic: "Letta Memory Blocks Integration - API, Sync Patterns, and Architecture"
tags: [research, letta, memory-blocks, sync, ARI-82]
status: complete
last_updated: 2026-01-13
last_updated_by: ariasulin
---

# Research: Letta Memory Blocks Integration

**Date**: 2026-01-13T17:24:51+07:00
**Researcher**: ariasulin
**Git Commit**: 7e5649b56d37976fb00dd567b1f1ee344cace890
**Branch**: main
**Repository**: YouLab

## Research Question

Understand Letta integration for memory blocks sync:
1. Letta blocks API - `client.blocks.list()`, `create()`, `update()`
2. Current sync patterns between YouLab storage and Letta
3. `_sync_block_to_letta` method implementation
4. Block naming conventions
5. Archival vs working memory mapping to Letta concepts

Gap analysis: New spec says "notes are a class of memory blocks in letta" - understand bidirectional relationship.

## Summary

YouLab implements a **unidirectional sync** from Git storage → Letta. Memory blocks are stored as TOML files in Git (source of truth), converted to memory strings, and synced to Letta's global blocks API. The codebase uses **two distinct Letta blocks APIs**:

1. **Global blocks API** (`client.blocks.*`) - For creating/updating standalone blocks
2. **Agent-scoped blocks API** (`client.agents.blocks.*`) - For reading/updating blocks attached to specific agents

There is currently **no bidirectional sync** - Letta blocks are not synced back to Git. The new spec's vision of "notes as a class of memory blocks" would require implementing Letta → Git sync.

## Detailed Findings

### 1. Letta Blocks API Usage

#### Global Blocks API

The global API manages blocks independent of agents:

**`client.blocks.list()`** - Lists all blocks in Letta
- Used at `src/youlab_server/storage/blocks.py:184` and `:232`
- Used at `src/youlab_server/server/agents.py:88`
- Returns list of block objects with `.id`, `.name`, `.label`, `.value` attributes

**`client.blocks.create()`** - Creates new block
- Used at `src/youlab_server/storage/blocks.py:199-203` and `:252-256`
- Used at `src/youlab_server/server/agents.py:101-106`
- Parameters: `label`, `name`, `value`, `description` (optional)

**`client.blocks.update()`** - Updates existing block
- Used at `src/youlab_server/storage/blocks.py:192-195`
- Parameters: `block_id`, `value`

#### Agent-Scoped Blocks API

For blocks attached to specific agents:

**`client.agents.blocks.list(agent_id)`** - Lists blocks for an agent
- Used at `src/youlab_server/tools/curriculum.py:200` and `:307`
- Returns blocks attached to that specific agent

**`client.agents.blocks.update(agent_id, block_id, value)`** - Updates agent's block
- Used at `src/youlab_server/tools/curriculum.py:311-315`
- Updates block in agent's core memory context

### 2. Block Naming Conventions

Two naming patterns are used:

**User-scoped blocks**: `youlab_user_{user_id}_{label}`
- Generated by `_letta_block_name()` at `storage/blocks.py:44-46`
- Example: `youlab_user_abc123_human`

**Shared blocks**: `youlab_shared_{course_id}_{label}`
- Generated at `server/agents.py:55`
- Example: `youlab_shared_college-essay_team`

### 3. Current Sync Patterns

#### Pattern 1: User Edit → Git → Letta (Primary)

```
User edits block (via API)
  → UserBlockManager.update_block_from_markdown/toml
    → GitUserStorage.write_block (creates git commit)
    → UserBlockManager._sync_block_to_letta
      → letta.blocks.update or letta.blocks.create
```

**Implementation** (`storage/blocks.py:163-211`):

```python
def _sync_block_to_letta(self, label: str, toml_content: str) -> None:
    block_name = self._letta_block_name(label)  # youlab_user_{user_id}_{label}

    # Parse TOML → memory string format
    data = tomllib.loads(toml_content)
    memory_str = self._toml_to_memory_string(data)

    # Find existing block by name
    blocks = self.letta.blocks.list()
    existing = next((b for b in blocks if getattr(b, "name", None) == block_name), None)

    if existing:
        self.letta.blocks.update(block_id=existing.id, value=memory_str)
    else:
        self.letta.blocks.create(label=label, name=block_name, value=memory_str)
```

#### Pattern 2: Agent Proposal → Pending Diff → Approval → Git → Letta

```
Agent calls edit_memory_block tool
  → UserBlockManager.propose_edit (creates pending diff)
  → (User reviews in UI)
  → User approves via API
    → UserBlockManager.approve_diff
      → UserBlockManager.update_block_from_toml
        → [Pattern 1 sync flow]
```

#### Pattern 3: Curriculum Tool Direct Update (No Git Sync)

```
Agent calls advance_lesson tool
  → _get_journey_block (reads from Letta)
  → _update_journey_block (writes to Letta)
  → NO sync back to Git
```

This pattern at `tools/curriculum.py:196-325` bypasses Git entirely - journey blocks are Letta-only.

#### Pattern 4: Agent Creation Block Attachment

```
API: POST /agents
  → AgentManager.create_agent_from_curriculum
    → Per-agent blocks: Build memory_blocks list
    → Shared blocks: Call _get_or_create_shared_block
    → letta.agents.create(memory_blocks=[...], block_ids=[...])
```

**Key distinction** (`server/agents.py:324-338`):
- `memory_blocks` param → Letta creates NEW blocks for this agent
- `block_ids` param → Letta attaches EXISTING shared blocks

### 4. Archival vs Working Memory

Letta has two memory tiers:

**Core Memory (Working)** - In-context blocks always visible to agent
- Implemented via `memory_blocks` and `block_ids` at agent creation
- Per-agent blocks: fresh copy for each agent
- Shared blocks: same block attached to multiple agents

**Archival Memory** - Vector-indexed long-term storage
- Used for context rotation when core memory exceeds threshold
- Used by strategy agent for RAG queries
- API: `client.insert_archival_memory()`, `client.get_archival_memory()`
- Implemented at `memory/manager.py:238-305` (deprecated)

**Current usage**:
- Core memory blocks: Active, via TOML config and UserBlockManager
- Archival memory: Limited use in deprecated MemoryManager and strategy agent

### 5. Gap Analysis: Notes as Memory Blocks

The new spec envisions "notes are a class of memory blocks in Letta." Current state:

| Aspect | Current State | Gap |
|--------|--------------|-----|
| **Source of truth** | Git (TOML files) | Need to support Letta as source for some block types |
| **Sync direction** | Git → Letta only | Need Letta → Git sync for bidirectional |
| **Block creation** | Via Git storage | Need direct Letta block creation for notes |
| **Versioning** | Git commits | Notes would need separate versioning in Letta or mirror to Git |
| **Schema** | TOML schemas in course config | Notes are freeform, blocks can be structured |

**Bidirectional sync challenges**:
1. **Conflict resolution**: What happens when both Git and Letta are modified?
2. **Format conversion**: Notes are Markdown, blocks are TOML → memory string
3. **Identity mapping**: How to map note IDs to Letta block IDs?
4. **Real-time sync**: Currently sync is triggered by explicit save operations

**Potential approaches**:
1. **Notes as a special block type**: Store notes in Git as `notes/{note_id}.md`, sync to Letta blocks with `label="note"`
2. **Letta-native notes**: Create notes directly in Letta, sync to Git on save
3. **Hybrid**: User notes stay in Git, agent-created notes live in Letta

### 6. Memory String Format

TOML is converted to a YAML-like string format for Letta (`storage/blocks.py:213-222`):

```python
def _toml_to_memory_string(self, data: dict[str, Any]) -> str:
    lines = []
    for key, value in data.items():
        if isinstance(value, list):
            items = "\n".join(f"- {item}" for item in value)
            lines.append(f"{key}:\n{items}")
        elif value:
            lines.append(f"{key}: {value}")
    return "\n\n".join(lines)
```

Example transformation:
```toml
# Input TOML
name = "Alice"
interests = ["writing", "philosophy"]
```
```yaml
# Output memory string
name: Alice

interests:
- writing
- philosophy
```

## Code References

| File | Lines | Purpose |
|------|-------|---------|
| `src/youlab_server/storage/blocks.py` | 21-395 | UserBlockManager - Git↔Letta sync, pending diffs |
| `src/youlab_server/storage/blocks.py` | 44-46 | `_letta_block_name()` - naming convention |
| `src/youlab_server/storage/blocks.py` | 163-211 | `_sync_block_to_letta()` - core sync logic |
| `src/youlab_server/storage/blocks.py` | 213-222 | `_toml_to_memory_string()` - format conversion |
| `src/youlab_server/server/agents.py` | 57-116 | `_get_or_create_shared_block()` - shared blocks |
| `src/youlab_server/server/agents.py` | 268-338 | Agent creation with memory blocks |
| `src/youlab_server/tools/curriculum.py` | 196-325 | Direct Letta block access (journey blocks) |
| `src/youlab_server/tools/memory.py` | 27-108 | `edit_memory_block` tool - agent-driven edits |
| `src/youlab_server/memory/manager.py` | 238-305 | Archival rotation (deprecated) |

## Architecture Documentation

### Block Attachment Flow

```
Course Config (TOML)
    ↓
BlockSchema { label, shared, fields }
    ↓
┌─────────────────────────────────────────┐
│ shared=false          │ shared=true     │
│ Per-agent block       │ Shared block    │
│ memory_blocks=[...]   │ block_ids=[...] │
└─────────────────────────────────────────┘
    ↓                         ↓
agents.create()          _get_or_create_shared_block()
    ↓                         ↓
Letta creates new       Letta attaches existing
block for agent         block to agent
```

### Sync Flow

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Git Storage   │────▶│ UserBlockManager│────▶│   Letta Blocks  │
│  (TOML files)   │     │  _sync_to_letta │     │   (API store)   │
└─────────────────┘     └─────────────────┘     └─────────────────┘
       ▲                                               │
       │                                               │
       │                    ❌ No reverse sync         │
       └───────────────────────────────────────────────┘
```

## Historical Context (from thoughts/)

Related research documents:
- `thoughts/shared/research/2026-01-01-letta-sdk-api-reference.md` - Comprehensive Letta SDK reference
- `thoughts/shared/research/2026-01-08-youlab-memory-philosophy.md` - Three paradigms: Letta, Honcho, curriculum
- `thoughts/shared/research/2026-01-13-ARI-82-current-memory-blocks-ari80.md` - Current memory blocks analysis
- `thoughts/global/shared/reference/letta-archival-memory.md` - Archival memory guide

## Related Research

- `thoughts/shared/plans/2026-01-12-ARI-80-memory-system-mvp.md` - Memory System MVP implementation
- `thoughts/shared/research/2026-01-12-ARI-78-unified-user-memory-blocks.md` - Unified user-level memory blocks

## Open Questions

1. **Bidirectional sync strategy**: Should notes sync Git→Letta→Git or be Letta-native?
2. **Block ID persistence**: How to maintain stable IDs across Git commits?
3. **Conflict resolution**: What's the merge strategy when both sides change?
4. **Real-time updates**: Should Letta block changes trigger webhooks to sync back?
5. **Schema enforcement**: How to handle freeform notes vs structured blocks in same system?
