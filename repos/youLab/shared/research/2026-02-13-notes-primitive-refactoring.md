---
date: 2026-02-13T09:21:05+00:00
researcher: ariasulin
git_commit: e33898fd156db6b6e6a17cd164eb34b7127a2917
branch: main
repository: YouLab
topic: "Notes Primitive: Refactoring LaTeX/PDF + Workspace Sync into DB-Backed Notes"
tags: [research, codebase, notes, latex, pdf, artifacts, dolt, sync, openwebui, memory-blocks]
status: complete
last_updated: 2026-02-13
last_updated_by: ariasulin
---

# Research: Notes Primitive — LaTeX/PDF + Workspace Sync Refactoring

**Date**: 2026-02-13T09:21:05+00:00
**Researcher**: ariasulin
**Git Commit**: e33898fd156db6b6e6a17cd164eb34b7127a2917
**Branch**: main
**Repository**: YouLab

## Research Question

The user wants to refactor two existing systems — (1) the LaTeX-to-PDF artifact pipeline and (2) the workspace-to-OpenWebUI-KB file sync — into a unified "notes" primitive. Notes would store `.tex` source code in Dolt (the existing database), compile to PDF on demand, and display as artifacts. This research documents all the existing components involved.

## Summary

Three independent systems currently handle note-like content and need to be understood for this refactoring:

1. **LaTeX/PDF Artifact Pipeline**: Agent writes `.tex` files to workspace → `HookedFileTools` auto-compiles via Tectonic → base64 PDF embedded in HTML → pushed to OpenWebUI artifact panel via HTTP POST + Socket.IO
2. **Workspace-to-OpenWebUI KB Sync**: Post-hooks on file mutations (`save_file`, `replace_file_chunk`, `delete_file`) → lazy sync individual files to per-user OpenWebUI knowledge bases
3. **Notes Adapter (existing)**: `api/notes_adapter.py` already bridges Dolt-backed memory blocks to OpenWebUI's NoteEditor API format — this is the closest existing analog to the desired "notes" primitive

The key insight is that the `notes_adapter.py` already provides a Notes-compatible API shape for Dolt-backed content. The refactoring would extend this pattern to store LaTeX source as Dolt "note" records, compile on access/save, and eliminate the filesystem intermediary.

---

## Detailed Findings

### 1. LaTeX/PDF Artifact Pipeline (Current State)

The system has no dedicated "LaTeX tool" — instead it hooks into standard file operations.

#### Components

**`src/ralph/tools/hooked_file_tools.py`** — `HookedFileTools` class
- Extends Agno's `FileTools`, overrides `save_file()` and `replace_file_chunk()`
- After successful file write, checks if filename ends with `.tex`
- If `.tex`, spawns a daemon thread calling `_compile_in_thread()` → `asyncio.run(compile_and_push(...))`
- **Fire-and-forget**: tool returns immediately; compilation happens in background
- **Agent-blind**: agent never learns about compilation success or failure
- Stores `user_id` and `chat_id` for artifact push targeting

**`src/ralph/artifacts.py`** — Compilation and push orchestration
- `compile_and_push(tex_path, user_id, chat_id)`: main entry point
- `_compile_latex(tex_path)`: runs `tectonic -X compile` as subprocess (120s timeout)
- `_build_viewer(pdf_bytes, title)`: base64-encodes PDF, substitutes into HTML template
- `_push_artifact(user_id, html, chat_id, title)`: HTTP POST to `{openwebui_url}/api/artifact/push`
- Error case: compilation errors are pushed as HTML error pages to the artifact panel

**`src/ralph/tools/latex_templates.py`** — Two templates
- `NOTES_TEMPLATE`: Full LaTeX document template (unused in current flow — agents write complete docs)
- `PDF_VIEWER_TEMPLATE`: Self-contained HTML with PDF.js 3.11.174 (UMD), continuous scroll, fit-to-width, ResizeObserver for responsiveness

**`src/ralph/server.py:247-258`** — Agent instructions tell the agent to:
1. Create/edit `.tex` files using `save_file`
2. Write complete LaTeX documents (not template-filling)
3. PDF auto-compiles and appears in artifact panel

#### Data Flow

```
Agent calls save_file("notes.tex", latex_content)
    ↓
HookedFileTools.save_file() writes to workspace/{user_id}/workspace/notes.tex
    ↓
Detects .tex → spawns daemon thread
    ↓
Thread: tectonic -X compile notes.tex → notes.pdf
    ↓
Thread: base64(pdf_bytes) → PDF_VIEWER_TEMPLATE substitution → full HTML string
    ↓
Thread: POST /api/artifact/push {user_id, chat_id, content: html, title}
    ↓
OpenWebUI: Socket.IO event → browser store update → Artifacts.svelte renders iframe
```

#### File Locations

- `.tex` files: `{user_data_dir}/{user_id}/workspace/` (default: `/data/ralph/users/{user_id}/workspace/`)
- `.pdf` files: same directory (generated by Tectonic, sibling to `.tex`)
- No database storage — everything lives on filesystem

---

### 2. Workspace-to-OpenWebUI KB Sync (Current State)

This system syncs workspace files (including `.tex` files) to OpenWebUI knowledge bases so they're available for RAG retrieval.

#### Components

**`src/ralph/sync/hooks.py`** — Post-hook attachment
- `attach_sync_hooks(file_tools, workspace, user_id)`: attaches `post_hook` closures to `save_file`, `replace_file_chunk`, `delete_file`
- Hook extracts `file_name` from `FunctionCall.arguments`, resolves to full path
- Fires `sync_file_to_kb()` as background task (fire-and-forget)
- Event loop handling: captures main loop during startup, uses `call_soon_threadsafe` for cross-thread scheduling

**`src/ralph/sync/workspace_sync.py`** — Core sync logic
- `sync_file_to_kb(file_path, user_id, client, knowledge)`: syncs one file
  - Gets/creates per-user KB via `KnowledgeService`
  - If file exists: deletes old version from KB, uploads new version
  - If file deleted: removes from KB
  - `.tex` files uploaded as `text/plain` (per `openwebui_client.py:34` extension list)
- `WorkspaceSync` class: full workspace scanning with SHA256 change detection, `.sync_state.json` persistence

**`src/ralph/sync/knowledge.py`** — Per-user KB management
- `KnowledgeService`: creates/resolves knowledge bases named `workspace-{user_id}`
- In-memory cache of user → KB ID mappings

**`src/ralph/sync/openwebui_client.py`** — HTTP client
- File upload/download via OpenWebUI `/api/v1/files/` endpoints
- Knowledge base CRUD via `/api/v1/knowledge/` endpoints
- `.tex` extension explicitly listed in `_TEXT_EXTENSIONS` for text/plain upload

**`src/ralph/sync/models.py`** — Data models
- `FileMetadata`: path, SHA256 hash, size, modified, openwebui_file_id
- `SyncState`: persisted as `.sync_state.json` in workspace
- `SyncResult`: success, files_uploaded/downloaded/deleted, errors

**`src/ralph/sync/service.py`** — Singletons
- Process-level `OpenWebUIClient` and `KnowledgeService` instances
- Initialized from `RALPH_OPENWEBUI_*` env vars

#### Data Flow

```
Agent calls save_file("notes.tex", content)
    ↓
Agno post_hook fires on function completion
    ↓
Hook: resolve file_path, validate within workspace
    ↓
Hook: fire_and_forget(sync_file_to_kb(file_path, user_id, client, knowledge))
    ↓
sync_file_to_kb: get_or_create_knowledge("workspace-{user_id}")
    ↓
sync_file_to_kb: find existing file by name in KB → delete old
    ↓
sync_file_to_kb: upload_file(filename, content, "text/plain") → add_file_to_knowledge(kb_id, file_id)
```

#### Important Detail

Both hook systems (LaTeX compilation and KB sync) are attached to the same file tools:
- LaTeX compilation: built into `HookedFileTools` class overrides
- KB sync: dynamically attached via `attach_sync_hooks()` (line 304 of server.py)
- Order: `HookedFileTools` created first → sync hooks attached second → fields stripped

---

### 3. Notes Adapter — Existing Dolt-to-OpenWebUI Bridge

**`src/ralph/api/notes_adapter.py`** — Already implements a Notes-compatible API

This adapter maps Dolt-backed memory blocks to OpenWebUI's NoteEditor API format. It's the closest existing component to the desired "notes" primitive.

#### Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/you/notes/` | GET | List all memory blocks as notes |
| `/you/notes/{note_id}` | GET | Get single note with Dolt version history |
| `/you/notes/{note_id}/update` | POST | Update a note (commits to Dolt) |

#### Data Shape Translation

The adapter converts between Dolt's `MemoryBlock` and OpenWebUI's `NoteModel`:

```python
# Dolt → Note translation (notes_adapter.py:149-172)
NoteResponse(
    id=block.label,           # label becomes note ID
    user_id=block.user_id,
    title=block.title,
    data=NoteData(
        content=NoteContent(
            html=_md_to_html(body),  # basic MD→HTML conversion
            md=body,                  # raw markdown body
            json_content=None,        # no TipTap JSON stored
        ),
        versions=[...],              # Dolt commit history
    ),
    created_at=updated_at,    # nanoseconds epoch
    updated_at=updated_at,
)
```

#### Version History

Each version maps from Dolt's `VersionInfo` to `NoteVersion`:
```python
NoteVersion(
    sha=version.commit_hash,      # Dolt commit hash
    message=version.message,       # commit message
    timestamp=version.timestamp,   # ISO timestamp
    md=body_at_version,           # body content at that commit
    html=_md_to_html(body),
)
```

---

### 4. Dolt Memory Blocks Schema (Storage Backend)

**`config/dolt/init.sql`** — Table definition

```sql
CREATE TABLE memory_blocks (
    user_id VARCHAR(255) NOT NULL,
    label VARCHAR(100) NOT NULL,
    title VARCHAR(255),
    body TEXT,
    schema_ref VARCHAR(255),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, label)
);
```

**Key characteristics**:
- Composite PK `(user_id, label)` — one row per user per block
- `body` is `TEXT` — stores markdown content
- `label` serves as the block identifier (e.g., `origin_story`, `tech_relationship`)
- Versioning via Dolt's native `dolt_history_*` tables and `dolt_log`
- Proposals via Dolt branches: `agent/{user_id}/{label}`

**DoltClient** (`src/ralph/dolt.py`) provides:
- `update_block()` — upsert + `DOLT_ADD` + `DOLT_COMMIT`
- `get_block_history()` — queries `dolt_history_memory_blocks`
- `get_block_at_version()` — content at specific commit hash
- `create_proposal()` — branch, update on branch, commit, return to main
- `approve_proposal()` / `reject_proposal()` — merge or delete branch

---

### 5. OpenWebUI Frontend Components

#### Notes UI (upstream OpenWebUI)
- `OpenWebUI/open-webui/src/lib/components/notes/NoteEditor.svelte` — TipTap rich text editor with autosave, undo/redo, versions
- `OpenWebUI/open-webui/src/lib/components/notes/NotePanel.svelte` — Side panel
- `OpenWebUI/open-webui/src/lib/components/notes/Notes.svelte` — Notes listing
- `OpenWebUI/open-webui/src/routes/(app)/notes/[id]/+page.svelte` — Note route
- `OpenWebUI/open-webui/src/lib/apis/notes/index.ts` — Notes API client

#### Artifacts UI (upstream OpenWebUI)
- `OpenWebUI/open-webui/src/lib/components/chat/Artifacts.svelte` — Renders HTML artifacts in sandboxed iframe via `srcdoc`
- `OpenWebUI/open-webui/backend/open_webui/routers/artifacts.py` — `/api/artifact/push` endpoint, triggers Socket.IO
- `OpenWebUI/open-webui/src/lib/stores/index.ts` — `showArtifacts`, `artifactCode`, `artifactContents` stores

#### YouLab Memory Block UI (custom)
- `OpenWebUI/open-webui/src/lib/components/you/BlockEditorPanel.svelte` — Memory block editor panel
- `OpenWebUI/open-webui/src/lib/components/you/MemoryBlockEditor.svelte` — Block editor
- `OpenWebUI/open-webui/src/lib/components/you/DiffApprovalOverlay.svelte` — Proposal approve/reject

---

### 6. openwebui-content-sync (External Tool)

**`openwebui-content-sync/`** — Standalone Go application (from `castai/openwebui-content-sync`)
- Multi-adapter content aggregation (GitHub, Confluence, Jira, Slack, local folders)
- Scheduled cron-based sync (vs Ralph's lazy post-hook sync)
- Separate from Ralph — different use case (org-wide KB population)
- Not directly relevant to the notes refactoring, but worth noting as the workspace-to-KB sync pattern was inspired by this tool

---

### 7. Agent Tool Wiring (server.py)

**`src/ralph/server.py:298-320`** — Current agent tool registration:

```python
file_tools = HookedFileTools(
    base_dir=workspace,
    user_id=request.user_id,
    chat_id=request.chat_id,
)
attach_sync_hooks(file_tools, workspace, request.user_id)
strip_agno_fields(file_tools)

agent = Agent(
    model=OpenRouter(...),
    tools=[
        strip_agno_fields(ShellTools(base_dir=workspace)),
        file_tools,                          # FileTools + LaTeX hooks + sync hooks
        strip_agno_fields(HonchoTools()),
        strip_agno_fields(MemoryBlockTools()),
    ],
    instructions=instructions,
    markdown=True,
)
```

The agent has 4 tool groups. The LaTeX functionality is embedded in `file_tools` (not a separate tool). The notes refactoring would likely add a new tool or modify the existing pattern.

---

## Code References

| File | Lines | Description |
|------|-------|-------------|
| `src/ralph/tools/hooked_file_tools.py` | 18-101 | HookedFileTools with LaTeX auto-compile |
| `src/ralph/artifacts.py` | 21-141 | compile_and_push, _compile_latex, _build_viewer, _push_artifact |
| `src/ralph/tools/latex_templates.py` | 5-189 | NOTES_TEMPLATE + PDF_VIEWER_TEMPLATE |
| `src/ralph/sync/hooks.py` | 70-126 | Sync hook creation and attachment |
| `src/ralph/sync/workspace_sync.py` | 68-125 | sync_file_to_kb single-file sync |
| `src/ralph/sync/knowledge.py` | 34-79 | KnowledgeService per-user KB management |
| `src/ralph/sync/openwebui_client.py` | 91-360 | OpenWebUI HTTP client |
| `src/ralph/sync/models.py` | 1-112 | FileMetadata, SyncState, SyncResult |
| `src/ralph/sync/service.py` | 1-56 | Singleton client/service management |
| `src/ralph/api/notes_adapter.py` | 1-307 | Notes-compatible API for Dolt-backed blocks |
| `src/ralph/dolt.py` | 32-42 | MemoryBlock dataclass |
| `src/ralph/dolt.py` | 109-196 | Block CRUD (list, get, update) |
| `src/ralph/dolt.py` | 221-316 | Version history + restore |
| `src/ralph/dolt.py` | 333-558 | Proposal system (create, list, diff, approve, reject) |
| `src/ralph/memory.py` | 79-136 | Welcome blocks + memory context builder |
| `src/ralph/server.py` | 247-258 | Agent LaTeX instructions |
| `src/ralph/server.py` | 298-320 | Agent tool wiring |
| `config/dolt/init.sql` | 7-15 | memory_blocks table schema |

## Architecture Documentation

### Current Patterns

1. **Fire-and-forget background work**: Both LaTeX compilation and KB sync run as background tasks that don't block tool responses. LaTeX uses daemon threads; sync uses asyncio tasks on the captured main loop.

2. **Hook composition**: Two independent hook systems attach to the same file tools — LaTeX hooks via class inheritance, sync hooks via dynamic `post_hook` attribute.

3. **Dolt as versioned store**: Memory blocks use Dolt's git-like branching for proposal workflows. The `notes_adapter.py` already translates this to OpenWebUI's NoteEditor format.

4. **Filesystem as intermediary**: Currently, `.tex` files live on disk in user workspaces. The agent writes them, hooks compile them, and the compiled PDFs are pushed as artifacts. There's no DB storage for note content.

5. **Agent-blind compilation**: The agent never learns whether compilation succeeded. It writes the `.tex` file and returns. Errors surface only in the artifact panel.

## Historical Context (from thoughts/)

- `thoughts/shared/plans/2026-01-13-ARI-82-memory-blocks-as-notes-plan.md` — Original 5-phase plan to expose memory blocks through OpenWebUI's NoteEditor. Phase 1 (storage format) completed; Phases 2-5 not started. The notes_adapter.py implements Phase 3's concept.
- `thoughts/shared/plans/2026-01-28-latex-pdf-notes-tool.md` — Original LaTeX tool plan with `render_notes()` as a dedicated Agno tool. The actual implementation diverged: instead of a dedicated tool, LaTeX compilation is hooked into standard FileTools.
- `thoughts/shared/research/2026-02-05-latex-artifacts-persistent-html-rendering.md` — Research on artifact rendering approaches. Documented 4 approaches (HTMLResponse, tool-emitted HTML, fetch-based artifact, frontend hack). Current implementation uses the artifact push approach (not documented in that research, developed later).
- `thoughts/shared/plans/2026-02-10-lazy-workspace-sync.md` — Plan for the current lazy sync implementation.
- `thoughts/shared/plans/2026-02-10-live-artifact-push.md` — Plan for the current artifact push system.

## Open Questions

1. **Schema extension**: Should notes be stored in the existing `memory_blocks` table (with a `type` column or label convention like `note_*`)? Or a new `notes` table in Dolt?
2. **Compilation trigger**: When LaTeX is stored in DB, when does compilation happen? On save (like current)? On demand when artifact is opened? Both?
3. **KB sync replacement**: If notes are DB-backed, does the workspace-to-KB sync become unnecessary for notes? Or does the compiled PDF still need to be in a KB for RAG?
4. **Agent tool interface**: Does the agent get a new `create_note` / `update_note` tool that stores LaTeX in Dolt directly? Or does it continue using `save_file` with hooks?
5. **Version history**: Dolt gives free versioning. How should note versions display in the UI — diff view of LaTeX source, or just version-dated PDFs?
6. **Existing workspace files**: Migration strategy for users who already have `.tex` files in their workspace?
